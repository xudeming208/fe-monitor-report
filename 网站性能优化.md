# 优化建议

## 前端
### 一. 打包优化
> 通过分析发现，打包完的静态资源都比较大，耗时主要在下载资源时。如果包不是很大的话，我们采取增量上线，只要不缓存入口HTML，其他静态资源都可以缓存

1. 去除不必要的插件。由于各种原因，打包文件包含了一大堆没必要的插件，npm包Depcheck可以检测没使用的包
2. 提取第三方库（利用webpack的splitChunks）。各种第三方的库，变化很少，我们完全可以单独打包，并设置强缓存（expires、cache-control），如：jQuery、react等等。当项目迭代时，不会再将第三方库打包进包里面了，可以减少包的大小，提高性能。拆分包后势必会增加http请求，我们可以将资源上传至不同域名或cdn，增加浏览器的并行下载能力，或者使用http2，多路复用
3. 由于项目迭代、换开发等各种原因，导致代码非常混乱，可以使用Tree Shaking或者npm包Depcheck去掉没使用的代码
4. 启用webpack的gzip压缩，这样尽可能的在打包时gzip压缩，而不是由服务器实时gzip压缩，节省服务器压缩时间及cpu,主要用的是compression-webpack-plugin插件。
	- nginx配置gzip_static on；这样Nginx服务器碰到已经压缩的文件(比如.gz结尾的文件)就不会再启用gzip压缩，这样可以节省Nginx服务器的cpu。
	- 同时应该配置gzip on;将要压缩的文件进行压缩。
	- 注意html不会引人.gz文件，而是会引入和.gz文件一样文件名的文件，所以我们压缩时，要保留源文件，并一起上传至Nginx
5. 可以使用webpack-bundle-analyzer研究包的大小情况，可以使用speed-measure-webpack-plugin来看打包的时间详情
6. 打包速度优化参考：[https://www.cnblogs.com/imwtr/p/7801973.html](https://www.cnblogs.com/imwtr/p/7801973.html)

```javascript
	
	// 提取第三方库。splitChunks配置参考
	optimization: {
		...config.optimization,
		splitChunks: {
			// chunks: 'initial',
			cacheGroups: {
				// 第三方不变的包，单独打包插入HTML。当项目迭代时，不会再将第三方库打包进包里面了，可以减少包的大小，提高性能
				'ant-react': {
					chunks: 'all',
					test: /ant|react/,
					name: "ant-react",
					priority: -1,
					reuseExistingChunk: true,
				},
				echarts: {
					chunks: 'all',
					test: /echarts/,
					name: "echarts",
					priority: -1,
					reuseExistingChunk: true,
				},

				// 以下是使用不到的包(比如其他npm包内部依赖的包)，将其单独打包，避免打包进入bundle.js
				'monaco-editor': {
					chunks: 'all',
					test: /monaco-editor/,
					name: "monaco-editor",
					priority: -1,
					reuseExistingChunk: true,
				},
			}
		}
	}
	
```
```javascript
	
	// webpack-bundle-analyzer配置参考
	plugins: [
		...config.plugins,
		new BundleAnalyzerPlugin({
			analyzerMode: 'server',
			analyzerHost: '127.0.0.1',
			analyzerPort: 8889,
			reportFilename: 'report.html',
			defaultSizes: 'parsed',
			openAnalyzer: true,
			generateStatsFile: false,
			statsFilename: 'stats.json',
			statsOptions: null,
			logLevel: 'info'
		}),
	]

```
```javascript

	// webpack的gzip压缩
	const CompressionPlugin = require("compression-webpack-plugin");
	plugins: [
		...config.plugins,
		new CompressionPlugin({
			test: /\.(js|css|html|svg)$/i,
			// 使用不到的包，禁用压缩，节省时间
			exclude: /monaco\-editor|tinymce|exceljs/,
			algorithm: 'gzip',
			compressionOptions: { level: 9 },
			// minRatio: 0.8,
			filename: '[file].gz[query]'
		}),
	]

```

### 二、页面优化
1. 为了减少页面白屏时间，须JS放页面后端，也要注意JS处理事件效率等，减少阻塞。资源延迟加载等提高首屏展示时间
2. 减少HTTP请求数。请求数多时，为了提高浏览器的并行能力，可采用多域名及cdn，配置域名预解析
3. 图片选择合适的格式（如webp，注意优雅降级）、大小及质量，icon可以通过雪碧图、font icon及base64等方式
4. 压缩静态资源。对于敏感资源，可以采用混淆压缩
5. 页面布局应语义化，也应避免标签、css层级太深
6. 善于使用本地存储（localStorage、sessionStorage）来缓存一些配置数据，比如国家、省份等信息
7. 可以通过performance.timing和performance.getEntries()查看页面资源的请求情况
8. 写代码时，时刻注意闭包、重绘、重排等，善于启用GPU，善于使用requestAnimationFrame、createDocumentFragment等等
9. 页面静态化
10. 更多建议请参考pagespeed或者yslow

## 后端
1. 尽量减少转发代理等次数
2. 对资源设置Content-Length属性，可以让浏览器提前知道数据的多少，而无需自己去实时检测数据是否传输完毕，提高其效率。
3. 对实时性要求不高的数据做缓存
4. 尽量瘦身接口返回内容，避免将一些用不到的数据也返回前端，导致传输数据量太大
5. 增加Server-Timing响应标头，方便我们了解请求的数据各个阶段所花费的时间，比如db时间等
6. 接口缓慢原因，是否因为配置太低，太多计算耗费CPU，导致性能降低，考虑更换更高性能的服务器

## 运维
1. 可以采用http2协议。多路复用、头部压缩等等优势
2. 对静态资源启用gzip压缩，压缩等级看需求而定，等级越高压缩比例越大，但是也越耗CPU。注意图片别gzip压缩
3. 对于常年不变或变化很少的资源，启用强制缓存（expires、cache-control），不请求网络；其他资源可以启用协商缓存，尽量使用lastModify，301返回头部，不返回body。尽量少用eTag，比较耗CPU，一定要etag时，尽量部分内容etag，避免全量etag
4. 对于重要项目或者pv、uv高项目，采用负载均衡

## 网络
1. CDN
2. dns缓存
3. 域名预解析
4. 负载均衡